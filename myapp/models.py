from myapp import db
from hashlib import md5

class User(db.Model):
	id = db.Column(db.Integer, primary_key=True)
	nickname = db.Column(db.String(64), index=True, unique=True)
	email = db.Column(db.String(120), index=True, unique=True)
	#Note that we have also added a new field to the User class called posts, that is constructed as a db.relationship field. This is 
	#not an actual database field, so it isn't in our database diagram. For a one-to-many relationship a db.relationship field is 
	#normally defined on the "one" side. With this relationship we get a user.posts member that gets us the list of posts from the 
	#user. The first argument to db.relationship indicates the "many" class of this relationship. The backref argument defines a field 
	#that will be added to the objects of the "many" class that points back at the "one" object. In our case this means that we can 
	#use post.author to get the User instance that created a post. 
	posts = db.relationship('Post', backref='author', lazy='dynamic')
	#Every time we modify the database we have to generate a new migration
	#If we did not have migration support you would have needed to edit your database manually, or worse, delete it and recreate it from scratch.
	about_me = db.Column(db.String(140))
	last_seen = db.Column(db.DateTime)

	#The is_authenticated property has a misleading name. In general this method should just return True unless the object represents a 
	#user that should not be allowed to authenticate for some reason.
	@property
	def is_authenticated(self):
		return True

	#The is_active property should return True for users unless they are inactive, for example because they have been banned.
	@property
	def is_active(self):
		return True

	#The is_anonymous property should return True only for fake users that are not supposed to log in to the system.
	@property
	def is_anonymous(self):
		return False

	#Finally, the get_id method should return a unique identifier for the user, in unicode format. We use the unique id generated by the 
	#database layer for this. Note that due to the differences in unicode handling between Python 2 and 3 we have to provide two alternative 
	#versions of this method.
	def get_id(self):
		try:
			return unicode(self.id) #python 2
		except NameError:
			return str(self.id) #python 3

	#The __repr__ method tells Python how to print objects of this class. We will use this for debugging.
	def __repr__(self):
		return '<User %r>' % (self.nickname)

	#The avatar method of User returns the URL of the user's avatar image, scaled to the requested size in pixels.
	# The d=mm determines what placeholder image is returned when a user does not have an Gravatar account. The mm option returns 
	#the "mystery man" image, a gray silhouette of a person. The s=N option requests the avatar scaled to the given size in pixels.
	def avatar(self, size):
		return 'http://www.gravatar.com/avatar/%s?d=mm&s=%d' % (md5(self.email.encode('utf-8')).hexdigest(), size)

	@staticmethod
	def make_unique_nickname(nickname):
		if User.query.filter_by(nickname=nickname).first() is None:
			return nickname
		version = 2
		while True:
			new_nickname = nickname + str(version)
			if User.query.filter_by(nickname=new_nickname).first() is None:
				break
			version += 1
		return new_nickname




class Post(db.Model):
	id = db.Column(db.Integer, primary_key=True)
	body = db.Column(db.String(140))
	timestamp = db.Column(db.DateTime)
	user_id = db.Column(db.Integer, db.ForeignKey('user.id'))

	def __repr__(self):
		return '<Post %r>' % (self.body)





